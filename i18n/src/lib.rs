//! Localization system of simple-icons website

use leptos::*;
use std::collections::HashMap;
use web_sys;

#[derive(Clone, Copy)]
pub struct Language {
    /// Language code
    pub code: &'static str,
    /// Language name
    pub name: &'static str,
}

pub static LANGUAGES: [Language; 3] = [
    Language {
        code: "en",
        name: "English",
    },
    Language {
        code: "es",
        name: "Español",
    },
    Language {
        code: "fr",
        name: "Français",
    },
];

impl Language {
    pub fn new() -> Self {
        initial_language_from_localstorage_or_navigator_languages()
    }

    pub fn translate(&self, key: &'static str) -> String {
        TRANSLATIONS
            .get(self.code)
            .and_then(|translations| translations.get(key))
            .unwrap_or(&key.to_string())
            .to_string()
    }
}

impl From<&str> for Language {
    fn from(code: &str) -> Self {
        LANGUAGES
            .iter()
            .find(|lang| lang.code == code)
            .unwrap_or(&LANGUAGES[0])
            .clone()
    }
}

impl Default for Language {
    fn default() -> Self {
        LANGUAGES[0]
    }
}

// Translations are generated by the build.rs script
include!(concat!(env!("OUT_DIR"), "/translations.rs"));

/// State of the localization
#[derive(Default, Clone, Copy)]
pub struct LocaleState {
    /// Current language of the website
    pub current_language: Language,
}

#[derive(Copy, Clone)]
pub struct LocaleStateSignal(pub RwSignal<LocaleState>);

fn initial_language_from_navigator_languages() -> Option<Language> {
    let languages = web_sys::window().unwrap().navigator().languages().to_vec();
    for raw_language in languages {
        let mut language =
            raw_language.as_string().expect("Language not parseable");
        if language.contains('-') {
            language = language.split_once('-').unwrap().0.to_string();
        }
        if let Some(lang) = Some(Language::from(language.as_str())) {
            return Some(lang);
        }
    }
    None
}

pub fn initial_language_from_localstorage_or_navigator_languages() -> Language {
    match initial_language_from_localstorage() {
        Some(lang) => lang,
        None => match initial_language_from_navigator_languages() {
            Some(lang) => lang,
            None => Language::default(),
        },
    }
}

fn initial_language_from_localstorage() -> Option<Language> {
    let window = web_sys::window().unwrap();
    let local_storage = window.local_storage().unwrap().unwrap();

    match local_storage.get_item("language") {
        Ok(Some(language)) => Some(Language::from(language.as_str())),
        _ => None,
    }
}

pub fn set_language_in_localstorage(lang: Language) {
    let window = web_sys::window().unwrap();
    let local_storage = window.local_storage().unwrap().unwrap();

    local_storage.set_item("language", lang.code).unwrap();
}

#[macro_export]
macro_rules! gettext {
    ($cx:ident, $key:expr) => {
        &use_context::<::i18n::LocaleStateSignal>($cx)
            .unwrap()
            .0
            .get()
            .current_language
            .translate($key)
    };
}
